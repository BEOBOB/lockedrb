<!-- See https://github.com/robinmoisson/staticrypt/blob/main/lib/password_template.html -->
<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="utf-8" />
    <title>Login</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.2.3/gh-fork-ribbon.min.css"
    />

    <style>
      .github-fork-ribbon:before {
        background-color: #333;
      }
    </style>

    <style>
      .staticrypt-hr {
        margin-top: 20px;
        margin-bottom: 20px;
        border: 0;
        border-top: 1px solid #eee;
      }

      .staticrypt-page {
        width: 360px;
        padding: 8% 0 0;
        margin: auto;
        box-sizing: border-box;
      }

      .staticrypt-form {
        position: relative;
        z-index: 1;
        background: #ffffff;
        max-width: 360px;
        margin: 0 auto 100px;
        padding: 45px;
        text-align: center;
        box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2),
          0 5px 5px 0 rgba(0, 0, 0, 0.24);
      }

      .staticrypt-form input[type="password"] {
        outline: 0;
        background: #f2f2f2;
        width: 100%;
        border: 0;
        margin: 0 0 15px;
        padding: 15px;
        box-sizing: border-box;
        font-size: 14px;
      }

      .staticrypt-form .staticrypt-decrypt-button {
        text-transform: uppercase;
        outline: 0;
        background: #113e9f;
        width: 100%;
        border: 0;
        padding: 15px;
        color: #ffffff;
        font-size: 14px;
        cursor: pointer;
      }

      .staticrypt-form .staticrypt-decrypt-button:hover,
      .staticrypt-form .staticrypt-decrypt-button:active,
      .staticrypt-form .staticrypt-decrypt-button:focus {
        background: #113e9f;
        filter: brightness(92%);
      }

      .staticrypt-html {
        height: 100%;
      }

      .staticrypt-body {
        height: 100%;
        margin: 0;
      }

      .staticrypt-content {
        height: 100%;
        margin-bottom: 1em;
        background: #e4e4e4;
        font-family: "Arial", sans-serif;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
      }

      .staticrypt-instructions {
        margin-top: -1em;
        margin-bottom: 1em;
      }

      .staticrypt-footer {
        position: fixed;
        height: 20px;
        font-size: 16px;
        padding: 2px;
        bottom: 0;
        left: 0;
        right: 0;
        margin-bottom: 0;
      }

      .staticrypt-footer p {
        margin: 2px;
        text-align: center;
        float: right;
      }

      .staticrypt-footer a {
        text-decoration: none;
      }

      .staticrypt-title {
        font-size: 1.5em;
      }

      label.staticrypt-remember {
        display: flex;
        align-items: center;
        margin-bottom: 1em;
      }

      .staticrypt-remember input[type="checkbox"] {
        transform: scale(1.5);
        margin-right: 1em;
      }

      .hidden {
        display: none !important;
      }

      .staticrypt-spinner-container {
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .staticrypt-spinner {
        display: inline-block;
        width: 2rem;
        height: 2rem;
        vertical-align: text-bottom;
        border: 0.25em solid gray;
        border-right-color: transparent;
        border-radius: 50%;
        -webkit-animation: spinner-border 0.75s linear infinite;
        animation: spinner-border 0.75s linear infinite;
        animation-duration: 0.75s;
        animation-timing-function: linear;
        animation-delay: 0s;
        animation-iteration-count: infinite;
        animation-direction: normal;
        animation-fill-mode: none;
        animation-play-state: running;
        animation-name: spinner-border;
      }

      @keyframes spinner-border {
        100% {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>

  <body class="staticrypt-body">
    <a
      class="github-fork-ribbon"
      href="https://github.com/a-nau/password-protected-website-template"
      data-ribbon="Template on GitHub"
      title="Template on GitHub"
    >
      Template on GitHub
    </a>
    <div id="staticrypt_loading" class="staticrypt-spinner-container">
      <div class="staticrypt-spinner"></div>
    </div>

    <div id="staticrypt_content" class="staticrypt-content hidden">
      <div class="staticrypt-page">
        <div class="staticrypt-form">
          <div class="staticrypt-instructions">
            <p class="staticrypt-title">Login</p>
            <p>Enter Password.</p>
          </div>

          <hr class="staticrypt-hr" />

          <form id="staticrypt-form" action="#" method="post">
            <input
              id="staticrypt-password"
              type="password"
              name="password"
              placeholder="Password"
              autofocus
            />

            <label
              id="staticrypt-remember-label"
              class="staticrypt-remember hidden"
            >
              <input id="staticrypt-remember" type="checkbox" name="remember" />
              Remember me
            </label>

            <input
              type="submit"
              class="staticrypt-decrypt-button"
              value="Open Page"
            />
          </form>
        </div>
      </div>
    </div>

    <footer class="staticrypt-footer">
      <p class="pull-right">
        Created with
        <a href="https://github.com/a-nau/password-protected-website-template"
          >PPW Template</a
        >
        and <a href="https://robinmoisson.github.io/staticrypt">StatiCrypt</a>.
      </p>
    </footer>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
      const templateError = "Bad password!",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"723a004accfa370e01b85e06f60adc3800bf9f74fdd910cc21c29d8730f108a6e9d1d6d17432e14dd37fc0d70c3fa53328c4ca445c9208cc7eb549d9726b3a4474aef8d25776de36d601e7b4f0f795adb3a5b9bc28d8c84365a37d018bf430617afa20a72404daf9a4abb2cd6f282300a0c9906ccbedf2f71729f7412202c8e94a085a6b6e4312d2a4e943b6f409fedb2c9536887d5fc9a7b70c0339de4d83facb323fe3fc78678608d18a43ea5e160e4c28af61098ae9f11883216c06abfcaa4b316ddd94c7caa839f12e7962fb79588e13c0065d6f6a902baa630601224a6b93aee9985b82fc08aa3277d6647b2ab45e93315f24b83b697e5647aac5c1548c99a58a1970f49ebe8c87596e7197ac56b1e55e14cc7f86b42a3fdad732aa61827ffe3f014ca689349daa40dac49958b2567e32dbb06d12cb3e33c8c0087d60279cea1d96b7dc6724afae13e03eb40354b7a1c637f6161d1cafd7f98015e942259a86b40e49bab99b1af50199fb396979d76b8ee0fda7066ecc4ab748e4a6dac4b1b9ac0109705bd5982978eb9830871f3976759d4cf5f376dd2bc1e8afc10e198079364a75f412bb86be132e2082df303178e87f6bc96034c825f1208d2a62bddb1e86232293f909c26064ab708fab1f60ef25fd6926dc90b177f037bbcc02a023fe9763ee553fdb6fad804212db88a7880e9d430ae79568b90667304d5bc806394067c3d54540f4c7d6b2cb6a9918528e8a4ad3fc8090059ad69a61e82617448cd875d14fdec2fc8cf325b723f248e14bbeff5a401a228a5190849cdb848294061a401c7d7f2c9a51fe26de6db77b074c7249d1db3862a10bf6f20d1ddfebb1508baa259c3b91c30a41e9f6f97ed56a26800306a511b1da7943ad2b9203f01b26070c1b2a665248c0c2341a06a1e9e459bc44979fd0e6452aa7deebcb0af39cb5487f92d82ce1e186521f54a7a296716532ecd8b129bf798561d838ceb3602b5f057163179892232749fc01bc4d6e676a6c449057f40e872e2d2b05697539ea8ad7f13043a3af0dca72939bbcdd2319abdb1d39088653f59e72936299ccb281bff989cecadd8eed1ba03a096d143eebf6ff351231d46127a88b212f9d34b7599f70f1d4e214a5026b23caaae02b3d018de02ff2f5cf7f8b0865710d84e06f217b823b734a345369b8a5960f8c136e931a63a0d1a1b3dbd2e0daf85db2df8cee36d2ad04d10e6fc7c0d1b5085206095904474997bc03afebd87435f1e6730d7c410244359649f572f754086408cb303166b1fa578cea449935bf942b81d790e648b18829eb211970550cdb945a04ade03a4d5342efbae92a8033b4f42e7809f4bc08f8945a0a69ae6b2a453e5e59a628c65cf5638edf806a1578916cb84e403b18aa5b8c1584c3a4ae2489b0c4bd45825e35d6e7008ccf8e6988b47591f02d42557a5fb8edfbc67e87decf5eb0f688da1a2f2cd31aa0afb24dcd2859ec60752881ebe861b4fb51b04509be0514e8c77f882ccebf090eb91b5b374b9ee5132ced48dba6efb101f8ff82102d41fe3b92d224c5ead3290d35b9364e582e56d14aabf8a6e699daa7fa04266e449bf2d6161ee2ad6aa61a43be5a0db09bfcb69c4282a3484554c946ba1c379c92df1b9540980b08a105ca0eead6ae1152ea841d1be3cc410ff61fe471ff43ff3d9ca1b9fc902758d18e7b25e6294c2561c29d74f92c931e7b4fedd8fdbf9346f0157c889cb6da096df69b362cbc3a6e3dbb12a97d19b7a1f7c32954cab7eddaa398851cfb0094d0f24150a0d251a0f47619ec8d5257c7cb27e1c9d93915a59893edb279261df916eb97cf3ac0a9a721bb1b933ae7cfda3eae4fbb043adecf5b6c19efbd0e59bcf05968b26fbb2ddc0b80eac46ec5d58949c6c95885049d0d68fb20fa117fe25eeebe478afd5bf6bee70609ae7ecadd6a225e2d74bb7ceecde65fae0ca34e7549404bb169ee01835b63f85a7bbbbc7abf8197353f5f986eed599637c2bc9db428b21c9da2af4e6f12b2d8a739339201a1bfd0f77f3cae13bf073bbd6df700a361a25ddfd1426987e53cea111e8ca70657a810ff9bb3bffb5da125f0c4626481049e609248a4baf6bef67518c998e1de132bde908ac81f97945388713dad52a673413c6d8b73dd9a03e2d10dda208cb3ee9d34c3bacff6b706f959c3c7d2100206b7d237212c87992e8c27d1cf541c17d7194a0a31b95cdd1a9a37aefe2a14e031b47ceadaeea5dfbb24e6473993406e66207c294f81dc69674aed5a6099f6b21bc2dc0f8b9e2a757485faf6fdf4ef08244ba47c45c262d8537909e5d9c0438c3c90b1e86081d6b13100f08921d4bed03624a5a05b88e8f838ad106ff4650b130819ee2cf6219ff1c0340a4276bfaa966d4082cb087d44987886da5b982a622ca9bf90b6f2a301822aeed4b2f849a5bf84bb2c1bbba90fafdaa9d12179eddb3ae1c96dbb0cea42ccf78a9b51a3dd60101cf840da64a8c0d76eeb6ed2035f86622ed1ffa233a38409ddcfc43c810af6173e160c9f51f7d143dfaf5eb476193bbe4fac922b1a1b49049db2b2160d5712fd4f8dcc3fbf14a0a60dfddf70aa1a32e443e495a7d5b94b39c1b90ae9b4df834b8d39bdf5b28d300050b9551a229bc67dfa3a20a7463eb64e2786234c459c18c34931fdc0f28b3e92575f9511df46124d33547b9a9d1d8986121d927c5ed2f0d14d41736f871c728080247ed9ddcdb3434a907c69d5346742ef715b84ef7055e956a43654d2eedb50c8cc62dd96f92c45833ba38d5fdaa7f3d688d3a7a37b0ff825a3e8aa6fb096776eedcfcc895eedeb5d39d6df29b0a016ec9f1fc9a95e217ead4d833e4591df8e95fde6a77aad56b14df908b229e5a016fc26d29ead253e3cfc1e271e2c5ac74a2e42be5305d06ffbdc3c4b35ce4ab98c6278efd6ba5582b93ad75bc7d97efd014c6e3ab9a9dc18093922e67a9caf6371a92e6d08f59af11f017347a03a1c42d2698a5430d179a3a773ab1aae584965c9888ff1f8ed34517f59717318622cc5522a32ead41b9cb44446b22aa4eea8dfcb3386bd1e5c89dc26d4b0f4fb7946a9ef438a16c38dcad819f51071db567fa23e75c8bf24f5743a621965301c11f27c67ca6801ebbc0cbbbeedc30c5fdf68915aedacc2f5c3ce981b978e116e9857f7ea4602aa443f2304ae2248d30ca121f6f0ee0abfc523c3aa9f85e9429a81576078b0154548aea423460e88f12ce4080887c724ebd5d55661c284c6b6883e6435f3c8d78e1859f5d9d0fa0b87b7d3ad5537a07158c1cafb2d92670a9761c8824397bbb57edb8e8be3cd1dfe0f7cbf4a1334fbf1163126e9364bbfcad048f5e7e33d2b9cbbd0ed415da4c6f3932e21ba53af94fd006b6af9361c1394e347b5232794c95f8213756cf065dedd4f35c8b6158ac1d20ef99c375d641d4494158ca582b95df07cd6dc084f8aa0415e6689acded604d218856940add5d9e349ee420ea8ef36a0c6855a5f14eb39e152550b0d53a04fa4b0212aecf7939e85e908aa3952a2f904a2458daf0eefb4f93740937684dddf1f8067e4e3e4c40b1761ce5e11d811c64ba027c0a1a4e0d806305501d76ffa45d7c4d852b751cf96217b71aa8f34085ce3b23c4e6a396567338a60bc3d7a88ad73a7ad51b4e81b8f32e3662ef78b42bc9f373b3fe4780f6b6db44ec77c1f1353d20a75f23add1fffb3269b779f0a08195cecd79696c58716fa3fab8b98bc57d5a4d426d837808a73841cb692d0161034709c0b191d0bf24b290417fb4307f2eec54ac440d090ed92d4eed660c951fcbb3dbaf983825edf45d55659090e7e02fa76b87b14081005475497bc1bc8a50729e25b3cc1f148bc1ef455fdba09dc398629fc3fabad74ed4afa5f9979cda05ac481320523f4b34df1551de375bb5253ade33159199610332fb1c5347de247dde8bf6753fe99c0d96a0c3f6be9519e026c43bc93eb6d024fdcaace7d2b43f585ceaa3443d089f12bcdb88e78f9f1c2c93efedb6859c63c4ebf917abb9919efeeb6857fe22c0c3033f292e0f844edd733e904be8e0b1a29934454e82a8aeb850475576c93acf81947fe2dfa73dd21a356a1512883a03038e27fcb2a0ceb96f42f4dff2cb6644ecf8ef1c900ea5dc1cd98694b731623a1494761d312618a3de4d1cd060266744d75a4e4cefe50eda3643e7f70dfb87a27efb0c223402bb25ead834e93db622017a15d618be6e75763cd42bfd5cce302e8cd9e258d049bc057186e47666472f4be5629956558e196617224d6879176bcbc8080014cb79823b6c84794c1bc7affbc75c7f48b2b79ee54591710ceeb9c5cc5d4dd757877eb4bc07b100495dd01b17547982b34cce145274093be6ac5723b14cf9411506d1ed01e1ba708630cba74e80d853956d04453723b9a7e8b3ddf8fc0087e6787da034ff12e1fbb945b5394272ccf7a634b6319434a92895afd64440a88964e01fc90972aebaae1f44482953533b4aaf1245546a4f0c29803e76fe09b79cf400aac08ee6f705c0cdec7ff8dbfbb57a0369d5757d083958b7eeb927d3e878638aab9d52ac1f7caf71f8b6a2cc649ffad5072ecb9b8be6bc643670d0c733de99d0193e825ac1b0cd58df8bf75d7e38708a32c804a1796fea8f188f2f9b2cdd995dea70de43f6c28b22a7173f81961c8da37f209cff29713aa846e9e4148ce474352efac401a0042a8437ee96468f3f116504854254f0b59f08d5ef25a9949d004d38601482e8dd81f798e1bf3abe4cdf7bd0d34596eac00c88199336d769687457253624cfeb7cc05c98a78d26d06324bc4d6378ffbb54dff4b2c5b6cc736b2cc5de699902dd8e1ad317210c2998bcfda7adef7962a59bbdbdce8c01ca7ee7a3f2335776d7e0c0bfd3704a4f6a6270415fcac3720ab7d9338f3829acb5c19e26ae425e958a3e95005b2c994813e2bb4a6e798b5d01339b9fd030bc09d3fb6e0323dffb6e08d2e2cc395bd18a02cdc5810f133f7f510323369fa11678519885dcc9cdbfeed6bcd00a9e0dd4d1b57cf12de31a1b91be28de77736c7825b7cb79912a216c14ef7d959a9b78aae5c13b834ee4ef6496598de767bb9fa1008abcea57809e663eb609ddc533b7ca941901c94574a2517333bb3b193ff2d2b1cc826fe770f8c7f66cb509106dcf712ab12b02e1cc5bb020d7ed7762817161b1d62b3ea5b1b41e8f5e08321633d6b94bf91ed20d3ecea64feccc2af2b12f97e022fb3c39ff6de7f7ac06e226fa6bc7ca0d5a96249297036458b5dd1604ce67169334e1dab607278685fa44e885b4049752e4524b0c78dfc6667aea53534b5ccf82b82f610312f0fa01eccc26a742c95b5f3f67f5fee41a36edde507b55eebc3c2cb5fe01ef352cbbf776d1db705a668302d23452d397b2006bd3d40490e5521dc2047db7d558d6a2df98d84a632a7483be703a415e0b7e04f912126be2981ed7d757787a6e6708cf7a8be76224dc133647a6f5a199da324dab4d307c8f252fab797c3fe8898fa867d7c3f91ae1f336e952bd9a2234a11c1f326ca5d5bbbab80218f74e15cce014092befc8e2b94816f5dbc82650cd66539c6a4a748c171ade77db6b2a658242d35486567d32a034c4e90ac4f190d5018b96aae5818546c34f9d754ca111f55f8e7a5b028d4c6dd8cde307b55ee7489840479cd9526b26ec16b53eed88eb9696dc86d82a002680d41c6737bcc7ef7e689e97b251d60a9a155b5c69df5b20b02d59943bdac30b65f94cef74d8d9559f8626dd1f3feabd031fee043b5bd34377da1a8cb264192c97e1e6f75fd20f40114e370e673befd9de91866a865c263d18e62eb658ab79b31ea2f848033f011291e49da3d327eca9d739a195f413101abff72531d8675425e10330cc01ce6a3ba3d4008674634f9eace68383ee671bb5a1995156447bbc8d1f8a097a4d5d28b1603494d334b5056c0a410ba406c2f25e76f8d61564e1346e41fc078b2812189bc8361cc1ca25feb2fc87db9769804678cbe4a3cab7d38d205ef71e9f0338d9cc091c2290a032a59e2d0cdee3a0d6078e1bc69d02dfc1d6e247c9f24c16582d2660f018e11a9b1c71ac6a9bb520e3838790ba2c06c6bb771ec0629ed97531c971b68c8fac5db7e5f6663181a54f25fd1a62218554bff5a30128b6303447d2b4a7bc4e3ee8af74641bc2457933f5a12036bb47faa500cc836ac82090b6345173dd11e8de167bf449b2b59f39179471dc4660e6280d83efba322f26e3ef8e4d1d73cf95966d732ab7d9ee15999c3e6b635641eaaf49916a60c5681036f40a31e34122541258d9ebb3d8e276c1d4dc9d029d60f4516be30aef1424167c22b156c326ed0afdf6a059d527bc77b0b3500b0a55a7d186364dab7d1e22e34879888dae4da610c3ddd1c8e431b8868acff2f97acbb414226b9970df7645b46966189f21b022a23518f83abb86babc2cc4b5bd13117175f1230375ccf6468f9c8598d1fa30a011890b900463cfd434e641023f00ab1624c6ce5c4469602d3ccf6ced8dbb29fbfb325fe7d4e14a847cb89638b7fd66b3d9ebd41cbbaa769b3e574e58a7939c4027332f4c5a7a21bacc3d81342e51bbad67c238c4f33c2458b0b035dcc68b37b00f0e31833617106a28212900e7beeaee1b6e3e0393ffc4755f2beeb042e9e45cbde6d10b575ddcd5f3363534f1dd6eb8ecc57a721ec47d7d2795ecaa030976989fbc17949a185731dcc3203856f00173f9f190ee62295172306b9dc7b48e08589a9009582b96bc47b4cd87d719ebc3804a2c4ef712ce2beaba934ca1fdf7d988586988f584784bfa42f03cdb5e3fe7573382b37f0b64056b9098ddda425d23ba1a144cb21b6a216bec98e43935f634844a4237a7b2b587c1cc882d3887adc8692dfba350645f0d86dc65da573ec6cebff48f918ee7fe733f6628386c9059685541fb68e10f25ac0dd66c4f23876358e8d0aed74434766e594567aaf99066dca05699ae7540c778505850218157b90497e7fff5bb8a99dd9543e34f68b66dff20b86662637c29a02a4e0079b2a037e249df796fa8977a5f8c8f99557fa318b6a34c706c7460136fbf9fac4a5a033985aadf7a9c85c36c7e8cf5c6fe9a130c8066bd30dfd5b9d998761bda16025d4844ac18e8cd7fb9a93c342239fd4a69567b525e76e726ef9aa56eaf1fa2c6bb647c9495334421c6edac5972fdbf4663e78e8acf83437a1051cb39592cfa5fc0148b4572ccf64be87a65676edfc75823ae21417352aedd20511d98a478f2c4ac70a0b7b204744d7b8b00ea7d7169d9aabe2315ea50986d2180adaba7b817f1c06ab0a815c051969f120fb9a790c8d76219af6aeab53d5a60f69b05911ea75194112dc82b1519795de968bf994504215e896c0560a956811126e67dee76d6a2dbf4754263cefddb320c25c0dc3667823797175b0607b84d53f1d70c2b2d9a5a1d0071580109b9713f2d235ba6e55352d95b9b386d116768f7e3b20da371d76379ea315b9a95f1332c3cd67134946560b4a47aec54751ebe055d651a25589c03a09f55da5e6fa4e38c3820b12d8e54fd6d7c878b869b2e3dcac475717d411f97e46e96d9b914fe57a0277ad01fc6d42d3863a26065badb6a27f42c37d8724e38917f18abd2f31ee7f93138db3f6b80ac3b3678c2190e4fa86283bef593ede4de49062ee6e8e0831fb2e924e78f86e7aca4ff81cf6be12c660771ec6e69eebbc6ea1fe28a1cd7f245a092ef17bbcc07e209197cd0275ff3daf78437088b7711c9b3a486d5f2fd5dfd2b69842499dea4a20edc78f7c2f2c217ce0f3b8704726db8cf4f94c83a8ead2c7e6198fcfa60336c9fbb4976363ce6114f55eb9e84a1f8b6a50145597709b648a70dbe9a9e79ecc02b2b692512cb6e2297241fc366e09452ce2894be656f5e7da5b034e13ebd12f8e73d41aba37f6c9b9581d52fa70436ba5b2529bef1edd1cbb4b6aeb05446845d914f6232e39c5127ef641eb4caa2a7df3d6c8b413bcbdca7ea1817b8f47b99f1359504b3a45ec9d0990989f6008be197705342596b6a875b6f72a02aae396372c08521d3f6da06f58ce772b1f5c63098927b952e886e49020f36f6b7eaa15976f0a13d3182b639a6c38c691a14af3a52daf625942b3c4c8a40a45f07d81229c5404653cf168233aa06b8cf1ccdcfe90611906ef3e874123947d3afa4a75b92b181a9e4a83112fb542e92db351f229e799899c2c3e99c3cb33c65aca871733276a0fd974ee36df8f47e3e70faf339da51f09126180b98205dd92277b988b1d182338f3087dfacb9c3fd7050f894c67457134bf707310370bd7599e6f182b08ca00bfa86455feccb66793e02a9acfdd5b07be297cc36b2299b4cf3eb4c644de9404cdca8e618017442127c790547efbfb0606363215d32cbfda32b8aaf2507926a35857544097cbe60dfbf071000ad82e849961d35672a86f997a2541dc770133a287a69d3ca6fab4b8356ffac9caa5ca4b2088d8cea925d0e29c0f2e3018d27ac2f10490fec1b08ee8a776232a2559836cb97b8309ea350a362e865a8f81c032636f08a0d0de5f16884f35720cc5eec652835c816b246386632315c798c36d2ba0e0c0cb9a1fa2db46e4d77585958d3caa195a9100fe67720a4432a8210dcbf858a84a44d8e42226358404d133fcd9cdbeefb9f49c8400d3b8cd5172cd5ec978344bc827b6f7c32447bfe72551d6eb5b671e29e76f1f0d14b006e00305b2da5c567b4defd25469c7c87d91b0f30ad80eee87e9376e741952073cdd2189b9c7bbb37266811227cb47aad8857ee4cc94837960440977cbb09a72cab0246c8e2a12f3cd2e4b674acf2f8fd906f7b13878e3a02ca3cec1e2560cb3142cd3694d14a5eb13b643fe12b62037cb7d87739a0970b6906f7bfbb9fc45c8744acb5859107377f649957851c4170d3c164f636e63ddb181c25f545fd0267c553ff2e09b7f2c0930579347a7d480494cf5245b3e4e916c942125bfb493998d66bda71235ba7216e624e676bb6f679dd1bfda1b4ba2593ec252fc1add85bab2722fbaaf6eeb4057d1751b8193354f65a39158f11db0452ba8604babe96b8d1a7faf1fd746c3b17563c9f8648b2730aa0a3ca9ffdaf8dd277d8b36795d174062391156f9e3d0498ceb126584a0a1c0f2ad837270ad9207a24aad3f21c6dfa2f027e90132b618fc5d36ed5123a29618089ed927151cc204eb83a896cbbebcc3ca028f263fd050f9816116f1d023de8184181240773392cbb42aad1fb95fbeab347d34bd4ca64dc4f1a090f8ada1234f2dcaf44a73c0aff0d8baa58b287b4e82a466912481dcc70ec57e35b93c3760e8e6e2318ea8e8e12ad26304e4965b11b0cae245a03f868f279beb7d6725dfdb9496a14a15a2eb169211396abeba55e9f3b8aeae08a0ac82c002a8392456863f172ade0830cc2c9380aab2cb374b6066b2a956d031450ca78ee4cc0ba5c48369683553f512c625d1ec253314b6688f9f398a29e7af855c1e8e92a86e8a60ac6f515dadd75535d1e41ef1a3b73356fde8232486ce16bef4e7029383a41293c0917831e6edee326df65b36e60ef616006b6580420b2e788c9ec5613b555c73d52282325fe1d434d20cb47bcb90eaa896ede31459d6786b4abaabb402fa12ee50f5a412eaf34348e2eabc3514bea4f8f59524130f9ac4ebb059637b7af9e401ec4c7eb698355fe1184e0d30cd50a4d3d66f78d5783015ca2fa81c84f388b72d0e3edb336046b1ce639c4a09b55f7a7394cb888de27e17689ec3e18213b0f681efeabc5f4fc4b5c4178a3e65362ce4d4b600cc23f132787b9e8e94d50915f163bceb7df06cabf0587a09f688aaf7a50b69904ba886a8a1af68cb4d8d1227217ac887024ea9168ec560ebadec7b229428890266ef08a20694637240b72d78be326219e070e6691e559457029fb0dcc1a4558df406bd170f2909ed5e4548e7984ab5282cb6102a978f6e9e51c25ea74d88bc62258e0f554e282c9110c7371f4b631739b3089f5fb63a3c4ee2c72a91f45b047d565255837174795f98d01297c9e3cdb23e1d7d8c52f5cd2b5e621d90e11b52783e4b603f5ce7c2ffe76a77a33dca9e073717bd56a670b4671439a35ce1467a4dfbdf56d65b2cabd2a7c3b94eb617a635148c5a07918f4301f8c0a3f264afe574194b2baeed60c7d06533723cf06f7712972a22233e3ca03c17cef748a7e6f21ab850f853f5ad837d4c67a3034e8cf5c186a8b269c4ea5ebc8794892184bc3130291522b22ccf918c7bfdf0127625f09c29758309f53bf77dca2528fb9e0b3f943ffb137e97d88dadbe2a8268f372eb34d132a6b2c75bb869176e874342dd158626f0bb1bb3df8a71528ff4533f2331de93f623c3b0d5d18c545ee91fc1ebc9beff5737cefb6ef112cf94415a514c1f24b0967236a2538145bb400bbca23f9925d5143eed5ca9bf1f931b6add83cdc7b4c78a79b3e9b8bc483a4d4a65449b208b15a73b6dba73da612f005c8ef34477912fe46b9d50ba461dc6587682e023dadd7a1679d00db62a98d3d66ca26354ce18675d51fb05dab3bad152393f1c70814064223b5b403268f8e6f2cbe300a35b056f3bbc90fc8ef533d33f8c026c660f7943721b8937d59a2fabf49c91f8f4f442eb4154fb8bb15fcdcbfe7114f2aee52820721cb240382c88892ff2cb31d51f350c04fef20bef3ac124d86c43532fa9881e2cacaa0084bba35f83c1b54aa610e060a06fe1d1b37b1b14e170398cc6ab1dc086b766125c7305487398ab6f40238f40edb8814da1af914860406d467414731bc7a7f842de72d4da9ff182261b7b65a16004ef3d78ef9f843ab9967a67ca04f4cd066fcadf6e067695230237fda1086ed9c3d8d8afbfdf68dec0bd54743c32a3c3dba4844f6d4c1bc83ab2d3556504a308277eacb3544ebe01d1ca9b6a950f4d44258cd2911ea1bf3d078fe9c284a2c4c7ee6f0961b767e01b8fe7577068431a34c60a9dc8ab122f73a0a814d46f6afc8ab590207203bbfdbe024e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"711d85b3f4f7ff82fa882d97cae68c5c"};

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();

          // show the remember me checkbox
          if (isRememberEnabled) {
            document
              .getElementById("staticrypt-remember-label")
              .classList.remove("hidden");
          }
        }
      };

      // handle password form submission
      document
        .getElementById("staticrypt-form")
        .addEventListener("submit", async function (e) {
          e.preventDefault();

          const passphrase = document.getElementById(
              "staticrypt-password"
            ).value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            passphrase,
            isRememberChecked
          );

          if (!isSuccessful) {
            alert(templateError);
          }
        });
    </script>
  </body>
</html>
